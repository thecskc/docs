---
title: "How Test Flows Work"
---

![Test Flow Diagram Pn](/images/test-flow-diagram.png)

# Testing Flows

Testing Flows allow you to define precise test cases for Jina to execute:

- **Prompt Definition**: You start by providing Jina with a prompt, including:
  - Context about your product
  - The overall objective of the test
  - Detailed instructions (specific steps, assertions, or validations)
- **Granularity**: The specificity of your instructions directly determines how detailed and granular your test case becomes.
- **Scheduling & Authentication**: You can schedule tests to run automatically and include any necessary authentication details to ensure seamless execution.

# Exploration

After defining the Testing Flow, Jina automatically explores your app to refine and translate your instructions into actionable test steps:

- **Automated Step Creation**: Jina generates granular, actionable test steps composed of atomic actions like clicking, typing, or navigating within your app.
- **Assertions**: Some test steps may include assertions depending on Jina's interpretation and decisions during exploration. These assertions define conditions Jina will verify during testing.

Once generated, these test steps remain consistent and reproducible across subsequent runs unless explicitly modified or versioned.

## Versioning

Test steps are versioned explicitly:

- Test steps remain unchanged between runs unless you explicitly edit the test prompt or create a new version due to updates or changes in your app.
- Each modification or update to your Testing Flow results in a new version of the test steps, clearly separating iterations and preserving previous configurations for reference or rollback.

# Test Representation

Jina leverages Playwright for robust, deterministic test execution:

- **Playwright Integration**: Test steps and atomic actions are executed as deterministic Playwright code. Execution is reliable and repeatable, especially when cached. Even uncached runs generate executable code, eliminating probabilistic outcomes.
- **Vision-Based Assertions**:
  - Assertions are initially inferred by leveraging LLMs (Large Language Models), utilizing screenshots, DOM structure, and app metadata as inputs. This approach emulates human-like evaluation, enabling verification beyond simple DOM-based checksâ€”such as visual element presence or correctness.
  - Avoids common brittleness associated with traditional DOM selector-based assertions, offering more flexible and robust tests, including image validations.
  - Future support includes the ability to convert these assertions directly into Playwright assertions if preferred, providing flexibility to match your testing needs.